<!DOCTYPE HTML> 
<html> 

<script src="unit teapot.js"></script>
<script src="gl-matrix-min.js"></script>

<script>
var gl;
var shaderProgram;
var modelview_uniform;
var normal_uniform;
var projection_uniform;
var texture, texture2;
var cube_vertex_buffer;
var cube_triangle_buffer;
var sampler_uniform;
var sampler2_uniform;
var teapot_vao;
var vert_pos_attr;
var vert_normal_attr;
var vert_texcoord_attr;

//
// a default vertex shader implemented as a backquoted string variable
//

var vs = `#version 300 es

precision mediump float;

const float PI = 3.1415926535897932384626433832795;

in vec3 aVertexPosition;
in vec3 aVertexNormal;
in vec2 aTexCoord;

uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
uniform mat4 uProjectionMatrix;

uniform vec3 uLightPosition;

out vec2 vTexCoord;
out vec3 vNormal;
out vec4 color;

void main() {
  // -- Cylindrical Texture -- 
  vec3 modelPosition = normalize(aVertexPosition);
  modelPosition.y -= 1.0;
  modelPosition = normalize(modelPosition);
  // aVertexPosition.x + 0.5;
  // vTexCoord.s = -atan(-modelPosition.z, -modelPosition.x) / 2.0 / PI + 0.5;
  // aVertexPosition.y + 0.5;
  // vTexCoord.t = modelPosition.y + 0.1;
  vTexCoord = aTexCoord;


  // -- Light --
  // Normal(n) in eye coords
  vec3 n = normalize(uNormalMatrix * aVertexNormal);

  // Vertex Position in eye coords
  vec4 p4 = uModelViewMatrix * vec4(aVertexPosition, 1.0);
  vec3 p3 = p4.xyz / p4.w;
  vec3 v = -normalize(p4.xyz);

  // Vector(l) to the light sourse
  // vec3 l = normalize(uNormalMatrix * vec3(0.0,1.0,0.0));
  vec3 l = normalize(uLightPosition - p3);
  
  // -- Ambient Light -- 
  // Ka = .5
  vec4 ambient_color = vec4(1.0,1.0,1.0,1.0);


  // -- Diffuse Light -- 
  // Kd = .5
  vec4 diffuse_color = vec4(1.0,1.0,1.0,1.0) * 0.5 * max(0.0, dot(n, l));


  // -- Specular Light -- 
  // Reflection vector(r)
  vec3 r = normalize(reflect(-l, n));
  // Ks = .5
  vec4 specular_color = vec4(1.0,1.0,1.0,1.0) * 0.5 * pow(max(0.0, dot(v, r)), 200.0);
  

  color = ambient_color + diffuse_color + specular_color;

  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
}
`;

//
// a default fragment shader implemented as a backquoted string variable
//

var fs = `#version 300 es

precision mediump float;
    
in vec3 vNormal;
in vec2 vTexCoord;
in vec4 color;

uniform sampler2D uSampler;
uniform sampler2D uSampler2;

out vec4 outColor;
    
void main() {
  vec3 illinois = vec3(texture(uSampler, vTexCoord));
  vec3 stadium = vec3(texture(uSampler2, vTexCoord));
  vec3 c = 0.5 * illinois + 0.5 * stadium;
  
  outColor = color * vec4(c,1.0);
}
`;

function setnormals(positions, normals, faces) {
    for (var i = 0; i < faces.length; i += 3) {
        // -- FACE --
        var vertex1 = glMatrix.vec3.fromValues(positions[faces[i]*3], positions[faces[i]*3+1], positions[faces[i]*3+2]);
        var vertex2 = glMatrix.vec3.fromValues(positions[faces[i+1]*3], positions[faces[i+1]*3+1], positions[faces[i+1]*3+2]);
        var vertex3 = glMatrix.vec3.fromValues(positions[faces[i+2]*3], positions[faces[i+2]*3+1], positions[faces[i+2]*3+2]);

        // Normal of the face
        var v1 = glMatrix.vec3.create();
        var v2 = glMatrix.vec3.create();
        var normal_face = glMatrix.vec3.create();
        glMatrix.vec3.subtract(v1, vertex2, vertex1);
        glMatrix.vec3.subtract(v2, vertex3, vertex1);
        glMatrix.vec3.cross(normal_face, v1, v2);

        normals[faces[i]*3  ] += normal_face[0];
        normals[faces[i]*3+1] += normal_face[1];
        normals[faces[i]*3+2] += normal_face[2];

        normals[faces[i+1]*3  ] += normal_face[0];
        normals[faces[i+1]*3+1] += normal_face[1];
        normals[faces[i+1]*3+2] += normal_face[2];

        normals[faces[i+2]*3  ] += normal_face[0];
        normals[faces[i+2]*3+1] += normal_face[1];
        normals[faces[i+2]*3+2] += normal_face[2];
    }

    for (var i = 0; i < normals.length; i += 3) {
        var vertex = glMatrix.vec3.fromValues(normals[i], normals[i+1], normals[i+2]);
        glMatrix.vec3.normalize(vertex, vertex);
        normals[i  ] = vertex[0];
        normals[i+1] = vertex[1];
        normals[i+2] = vertex[2];
    }
    return normals;
}
function isPowerOf2(value) {
    return (value & (value - 1)) == 0;
}

function handleTextureLoaded(image, texture) {
    console.log("handleTextureLoaded, image = " + image);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
    // Check if the image is a power of 2 in both dimensions.
    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
        // Yes, it's a power of 2. Generate mips.
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        console.log("Loaded power of 2 texture");
    } else {
        // No, it's not a power of 2. Turn of mips and set wrapping to clamp to edge
        gl.texParameteri(gl.TETXURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TETXURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TETXURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        console.log("Loaded non-power of 2 texture");
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
}

function loadCubeMapFace(gl, target, cube_texture, url){
    var image = new Image();
    image.onload = function()
    {
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, cube_texture);
      gl.texImage2D(target,0,gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      handleTextureLoaded(image, cube_texture);
    }
    image.src = url;
}

function initwebgl() {

  //
  // create a graphics context
  //

  var canvas = document.getElementById("myGLCanvas");
  gl = canvas.getContext("webgl2");
  if (!gl)
    alert("Failed to create WebGL context!");

  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

  loadshaders(vs,fs);

  // set up vertex array object

  teapot_vao = gl.createVertexArray();
  gl.bindVertexArray(teapot_vao);

  // create a coordinate buffer of vertex positions and
  // connect it to the vertex shader positions

  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(teapot.positions),
                gl.STATIC_DRAW);

  gl.enableVertexAttribArray(vert_pos_attr);
  gl.vertexAttribPointer(vert_pos_attr, 3, gl.FLOAT, false, 0, 0);

  // create a coordinate buffer of vertex positions and
  // connect it to the vertex shader positions
  // but normalize the normals first

  var x,y,z,d;
  for (var i = 0; i < teapot.normals.length; i += 3) {
    x = teapot.normals[i];
    y = teapot.normals[i+1];
    z = teapot.normals[i+2];

    d = 1.0/Math.sqrt(x*x + y*y + z*z);

    teapot.normals[i] *= d;
    teapot.normals[i+1] *= d;
    teapot.normals[i+2] *= d;
  }

  // setnormals(teapot.positions, teapot.normals, teapot.faces);

  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(teapot.normals),
                gl.STATIC_DRAW);

  gl.enableVertexAttribArray(vert_normal_attr);
  gl.vertexAttribPointer(vert_normal_attr, 3, gl.FLOAT, false, 0, 0);

  // create an index buffer of triangle faces

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); 
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(teapot.faces),
                gl.STATIC_DRAW);

  // -- Cube --
  cube_vertex_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cube_vertex_buffer);
  var cube_vertices = [
                        // Front face
                        -100.0, -100.0,  100.0,
                        100.0, -100.0,  100.0,
                        100.0,  100.0,  100.0,
                        -100.0,  100.0,  100.0,

                        // Back face
                        -100.0, -100.0, -100.0,
                        -100.0,  100.0, -100.0,
                        100.0,  100.0, -100.0,
                        100.0, -100.0, -100.0,

                        // Top face
                        -100.0,  100.0, -100.0,
                        -100.0,  100.0,  100.0,
                        100.0,  100.0,  100.0,
                        100.0,  100.0, -100.0,

                        // Bottom face
                        -100.0, -100.0, -100.0,
                        100.0, -100.0, -100.0,
                        100.0, -100.0,  100.0,
                        -100.0, -100.0,  100.0,

                        // Right face
                        100.0, -100.0, -100.0,
                        100.0,  100.0, -100.0,
                        100.0,  100.0,  100.0,
                        100.0, -100.0,  100.0,

                        // Left face
                        -100.0, -100.0, -100.0,
                        -100.0, -100.0,  100.0,
                        -100.0,  100.0,  100.0,
                        -100.0,  100.0, -100.0
                      ];

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube_vertices), gl.STATIC_DRAW);

  cube_triangle_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube_triangle_buffer);

  var cube_vertex_indices = [
                              0,  1,  2,      0,  2,  3,    // front
                              4,  5,  6,      4,  6,  7,    // back
                              8,  9,  10,     8,  10, 11,   // top
                              12, 13, 14,     12, 14, 15,   // bottom
                              16, 17, 18,     16, 18, 19,   // right
                              20, 21, 22,     20, 22, 23    // left
                            ];

  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube_vertex_indices), gl.STATIC_DRAW);
    
  //
  // set up texture and sampler
  //

  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);

  //
  // load texture image using webgl2fundamentals boilerplate
  // initially creates just a 1x1 blue pixel as a placeholder
  // replaced by actual texture image once loaded
  //

  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X, texture, "cube-right.png");
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, texture, "cube-left.png");
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, texture, "cube-top.png");
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, texture, "cube-bottom.png");
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, texture, "cube-front.png");
  loadCubeMapFace(gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, texture, "cube-back.png");
  
  
  
/*

  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  var sampler = gl.createSampler();
  gl.bindSampler(0, sampler);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
                gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

  var image = new Image();
  image.src = "illinois512.png";
  
  image.addEventListener("load", function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
  });
*/
  //
  // set up second texture and sampler
  //

  // texture2 = gl.createTexture();
  // gl.bindTexture(gl.TEXTURE_2D, texture2);
  // gl.activeTexture(gl.TEXTURE0);

  // var sampler2 = gl.createSampler();
  // gl.bindSampler(1, sampler2);

  //
  // load texture image using webgl2fundamentals boilerplate
  // initially creates just a 1x1 blue pixel as a placeholder
  // replaced by actual texture image once loaded
  //

  /*gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
                gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

  var image2 = new Image();
  image2.src = "stadium sphere.jpg";

  image2.addEventListener("load", function() {
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, image2);
    gl.generateMipmap(gl.TEXTURE_2D);
  });*/


  //
  // set up transformation matrices
  //

  projection = glMatrix.mat4.create();
  glMatrix.mat4.perspective(projection, Math.PI/6, 1.0, 0.1);

  requestAnimationFrame(draw);
}

function loadshaders(vertexShaderSource,fragmentShaderSource) {
  var vstextbox = document.getElementById("vertexshader");

  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
    alert("Vertex Shader Error:\n" + gl.getShaderInfoLog(vertexShader));

  var fstextbox = document.getElementById("fragmentshader");

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);
  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
    alert("Fragment Shader Error:\n" + gl.getShaderInfoLog(fragmentShader));

  //
  // Compile shaders and get link ID's to the attributes and uniforms
  //

  shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
    alert("Failed to setup shaders");

  vert_pos_attr = gl.getAttribLocation(shaderProgram, "aVertexPosition");
  vert_normal_attr = gl.getAttribLocation(shaderProgram, "aVertexNormal");
  modelview_uniform = gl.getUniformLocation(shaderProgram, "uModelViewMatrix"); 
  normal_uniform = gl.getUniformLocation(shaderProgram, "uNormalMatrix"); 
  projection_uniform = gl.getUniformLocation(shaderProgram, "uProjectionMatrix"); 
  sampler_uniform = gl.getUniformLocation(shaderProgram, "uSampler"); 
  sampler2_uniform = gl.getUniformLocation(shaderProgram, "uSampler2"); 
  vert_texcoord_attr = gl.getAttribLocation(shaderProgram, "aTexCoord");
}


//
// draw callback function that is passed to requestAnimationFrame()
//

function draw(time) {
  gl.clearColor(0.075, 0.16, 0.294, 1.0);
  gl.clearDepth(1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  modelview = glMatrix.mat4.create();
  glMatrix.mat4.translate(modelview,modelview,[0.0, 0.0, -2.0]);
  glMatrix.mat4.rotateY(modelview,modelview, time*0.001);

  normalmatrix = glMatrix.mat3.create();
  glMatrix.mat3.normalFromMat4(normalmatrix,modelview);

  gl.useProgram(shaderProgram);

  gl.uniformMatrix4fv(modelview_uniform, false, modelview);
  gl.uniformMatrix3fv(normal_uniform, false, normalmatrix);
  gl.uniformMatrix4fv(projection_uniform, false, projection);

  gl.uniform1i(sampler_uniform,0);
  gl.uniform1i(sampler2_uniform,1);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
  gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

  // Draw Cude
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube_triangle_buffer);
  gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
  // gl.activeTexture(gl.TEXTURE1);
  // gl.bindTexture(gl.TEXTURE_2D, texture2);

  gl.bindVertexArray(teapot_vao);
  gl.drawElements(gl.TRIANGLES,
                  teapot.faces.length,
                  gl.UNSIGNED_SHORT,
                  0);

  requestAnimationFrame(draw);
}


</script>

<body onload="initwebgl()">

<canvas id="myGLCanvas" width="500" height="500"></canvas>

</body>
</html>
